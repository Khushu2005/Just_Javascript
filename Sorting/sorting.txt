Algorithm	   Stability	In-Place
SelectionSort  Not stable	 Yes
MergeSort	   Stable	     No
BubbleSort	   Stable	     Yes

Bubble Sort â†’ Teaching & nearly sorted arrays
Selection Sort â†’ Jab swaps costly ho aur data chhota ho
Merge Sort â†’ Large datasets, linked lists, external sorting, stable sorting


Bubble Sort
// DEF: Bubble Sort repeatedly compares adjacent elements in an array and swaps them if they are in the wrong order. After each pass, the largest element â€œbubblesâ€ to the end.

// CONCEPT: Bubble sort is a simple comparison-based sorting algorithm. It repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.

// How Bubble Sort Works:

// Traverse through the list from index 0 to n-1.
// Compare the current element with the next element.
// If the current element is greater than the next element, swap them.
// After each full pass, the largest unsorted element "bubbles up" to its correct position.
// Repeat the process until no swaps are needed (the list is sorted).

// TIME COMPLEXITY :
// Best Case: O(n) - When the array is already sorted (only one pass needed).
// Average Case: O(n^2) - When the array is in random order (multiple passes needed).
// Worst Case: O(n^2) - When the array is in reverse order (maximum swaps and comparisons).

// SPACE COMPLEXITY :
// O(1) (in-place).

// Stability:
// ğŸ‘‰ Yes, Bubble Sort is stable because equal elements donâ€™t change their relative order.

// Q and A
// Q1. Why isnâ€™t Bubble Sort used in practice?
// ğŸ‘‰ Because its O(nÂ²) complexity makes it inefficient for large datasets. Faster algorithms like Quick Sort or Merge Sort exist.

// Q2. Is Bubble Sort stable? Why?
// ğŸ‘‰ Yes. Because it only swaps adjacent elements, equal elements keep their original order.

// Q3. Is Bubble Sort adaptive?
// ğŸ‘‰ Yes, in the optimized version with a swap flag â€” if the array is already sorted, it will stop in one pass (O(n)).



// ğŸ”¹ Advanced Level (Deep Dive)

// Q1. Compare Bubble Sort vs Insertion Sort.
// ğŸ‘‰ Both are O(nÂ²) worst case, but Insertion Sort is usually faster for small or nearly sorted arrays because it shifts elements instead of swapping repeatedly.

// Q2. Why is Bubble Sort bad for large datasets?
// ğŸ‘‰ Because it makes too many comparisons/swaps. For 1 million elements, it may take ~10Â¹Â² operations.

// Q3. How would you explain Bubble Sort to a beginner?
// ğŸ‘‰ Imagine lining up kids by height. You keep comparing two kids standing next to each other and swap them if the taller one is in front. After one full round, the tallest kid is at the end. Repeat until all are sorted.

// Q4. Can Bubble Sort detect a sorted array early?
// ğŸ‘‰ Yes, by using the swapped flag. If no swap happens in a pass, it means the array is already sorted.

// Q5. Can Bubble Sort be parallelized?
// ğŸ‘‰ Not efficiently, because it depends heavily on comparisons of adjacent elements.

// Q6. Where might Bubble Sort still be useful?
// ğŸ‘‰ For teaching sorting concepts, for very small arrays, or when simplicity matters more than efficiency.

selection sort 
// DEF: Selection Sort is a comparison-based sorting algorithm. It sorts an array by repeatedly selecting the smallest (or largest) element from the unsorted portion and swapping it with the first unsorted element. This process continues until the entire array is sorted.


// ğŸ’¡ Easy Trick yaad rakhne ka:
// Selection Sort = â€œBahar se sabse chhota element uthao aur sorted list ke aage chipka do.â€

// Array ko 2 parts maan lo â†’ Left (sorted) & Right (unsorted).
// Har pass me unsorted part se minimum element dhoondo.
// Us minimum ko current position ke element se swap karo.
// Sorted part ek element badh jata hai, unsorted ek element kam ho jata hai.
// Ye process n-1 passes tak repeat karo.
// Last tak poora array sorted ho jata hai âœ….


// âš¡ Complexity of Selection Sort
// 1. Best Case â†’ O(nÂ²)
// Array: [1, 2, 3, 4, 5](Already Sorted)
// Selection Sort kya karega ?

// Pass 1: Minimum dhoondega â†’ fir bhi pura array check karega(n - 1 comparisons)
// Pass 2: Baki array check karega(n - 2 comparisons)
// Pass 3: (n - 3 comparisons)... aur aise hi last tak
// ğŸ‘‰ Comparisons hamesha(n(n - 1)) / 2 â‰ˆ O(nÂ²) * honge.
// ğŸ‘‰ Matlab chahe array sorted ho, selection sort ko sab compare karna padta hai.

// 2. Worst Case â†’ O(nÂ²)
// Array: [5, 4, 3, 2, 1](Completely Reverse Sorted)
// Har pass me minimum dhoondhne ke liye again full traversal karna padega.
// Comparisons same rahenge: (n * (n - 1)) / 2 â‰ˆ O(nÂ²).
// Sirf swaps slightly different honge, but time same.

// 3. Average Case â†’ O(nÂ²)
// Array: [64, 25, 12, 22, 11](Random order)
// Har pass me minimum dhoondhne ke liye unsorted portion pura traverse karna padta hai.
// Average bhi hamesha O(nÂ²) hi rahega.

// 4. Space Complexity â†’ O(1)
// Kyunki ye array ke andar hi swap karta hai, koi extra data structure use nahi karta.
// Isliye isko in -place algorithm bolte hain.

// 5. Swaps â†’ Max(n - 1)
// Har pass me sirf ek swap hota hai(minimum element ko uski jagah le aana).

//   Example:
// Array size n = 5
// Max swaps = 4(Pass 1 me 1 swap, Pass 2 me 1 swap â€¦ last pass me swap ki zaroorat hi nahi).
// ğŸ‘‰ Bubble sort ke comparison me selection sort bahut kam swaps karta hai.

// 6. Stable ? âŒ
// Example: [4(1), 4(2), 3]
// Yahan 4(1) aur 4(2) do equal elements hain.
// Agar minimum 3 ko pick karke 4(1) ke sath swap kar diya, toh equal 4 elements ka relative order change ho gaya.
// ğŸ‘‰ Isliye by default Selection Sort stable nahi hota.

Merge Sort ->

//Definition
Merge Sort ek Divide & Conquer algorithm hai.
Array ko bar-bar do halves me todta hai, aur fir sorted halves ko merge karta hai.


2. Working (Steps)

ğŸ‘‰ Example: [8, 5, 2, 7, 1]
Divide: [8, 5, 2] + [7, 1]
Divide again: [8,5] + [2] , [7] + [1]
Conquer (merge): [8,5] â†’ [5,8]
Merge: [5,8] + [2] â†’ [2,5,8]
Merge: [7] + [1] â†’ [1,7]
Merge: [2,5,8] + [1,7] â†’ [1,2,5,7,8]


// Interview Keywords (Bolne ke liye ready rakho)
â€œMerge Sort ek divide and conquer algorithm hai.â€
â€œTime complexity hamesha O(n log n) hai â€“ best, worst, average sab case me.â€
â€œStable hai but in-place nahi hai (O(n) extra space lagta hai).â€
â€œLarge datasets aur linked lists me useful hai.â€
â€œSwaps kam hote hain, lekin memory overhead zyada hai.â€